namespace STM.BusinessCentral.Sentinel;

using STM.BusinessCentral.Sentinel;

/// <summary>
/// This table is used to store all the alerts that are generated by the system
/// </summary>
table 71180275 AlertSESTM
{
    Access = Public;
    Caption = 'Alert';
    DataClassification = SystemMetadata;
    DrillDownPageId = AlertListSESTM;
    Extensible = false;
    LookupPageId = AlertListSESTM;
    Permissions =
        tabledata AlertSESTM = RD,
        tabledata IgnoredAlertsSESTM = RID;

    fields
    {
        field(1; Id; BigInteger)
        {
            Caption = 'ID';
            NotBlank = true;
        }
        field(2; AlertCode; Enum "AlertCodeSESTM")
        {
            Caption = 'Code';
            NotBlank = true;
        }
        field(3; ShortDescription; Text[100])
        {
            Caption = 'Short Description';
        }
        field(4; LongDescription; Text[250])
        {
            Caption = 'Long Description';
        }
        field(5; Severity; Enum SeveritySESTM)
        {
            Caption = 'Severity';
        }
        field(6; ActionRecommendation; Text[250])
        {
            Caption = 'Action Recommendation';
        }
        field(7; "Area"; Enum AreaSESTM)
        {
            Caption = 'Area';
        }
        /// <summary>
        /// This is the unique Guid for a specific warning per Alert Code, not a an ID for the Alert Code. 
        /// Its used to allow the user to mark a warning as read
        /// </summary>
        field(8; UniqueIdentifier; Text[100])
        {
            Caption = 'Unique Identifier';
        }
        field(9; Ignore; Boolean)
        {
            CalcFormula = exist(IgnoredAlertsSESTM where(AlertCode = field(AlertCode), UniqueIdentifier = field(UniqueIdentifier)));
            Caption = 'Ignore';
            Editable = false;
            FieldClass = FlowField;
        }
    }

    keys
    {
        key(PK; Id)
        {
            Clustered = true;
        }
        key(UniqueId; AlertCode, UniqueIdentifier) { }
    }

    trigger OnInsert()
    begin
        if not NumberSequence.Exists('BCSentinelSESTMAlertId') then
            NumberSequence.Insert('BCSentinelSESTMAlertId');

        Rec.Id := NumberSequence.Next('BCSentinelSESTMAlertId');
    end;

    procedure FindNewAlerts()
    var
        currOrdinal: Integer;
        Alert: Interface IAuditAlertSESTM;
        AlertsToRun: List of [Interface IAuditAlertSESTM];
    begin
        foreach currOrdinal in Enum::AlertCodeSESTM.Ordinals() do
            AlertsToRun.Add(Enum::AlertCodeSESTM.FromInteger(currOrdinal));

        // TODO: add event to allow other extensions to add Alerts

        foreach Alert in AlertsToRun do
            Alert.CreateAlerts();

        Rec.FindFirst(); // Move to the first record
    end;

    procedure SetToIgnore()
    var
        IgnoredAlerts: Record IgnoredAlertsSESTM;
    begin
        if Rec.Ignore then
            exit;

        IgnoredAlerts.Validate(AlertCode, Rec.AlertCode);
        IgnoredAlerts.Validate(UniqueIdentifier, Rec.UniqueIdentifier);
        if not IgnoredAlerts.Insert(true) then
            exit;
    end;

    procedure ClearIgnore()
    var
        IgnoredAlerts: Record IgnoredAlertsSESTM;
    begin
        if not Rec.Ignore then
            exit;

        IgnoredAlerts.SetRange(AlertCode, Rec.AlertCode);
        IgnoredAlerts.SetRange(UniqueIdentifier, Rec.UniqueIdentifier);
        if not IgnoredAlerts.IsEmpty() then
            IgnoredAlerts.DeleteAll(true);
    end;

    procedure FullRerun()
    begin
        Rec.ClearAllAlerts();
        Rec.FindNewAlerts();
    end;

    procedure ClearAllAlerts()
    begin
        Rec.DeleteAll(true);
        NumberSequence.Restart('BCSentinelSESTMAlertId');
    end;
}